/*
 * Copyright (c) 2024 Shenzhen Kaihong Digital Industry Development Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "include/DrawingNativePenTest.h"
#include "include/OhosCommonTest.h"

namespace OHOS {
namespace Rosen {
namespace Drawing {

// Common SetUp and TearDown functions implementation
void DrawingNativePenTestSetUp()
{
    std::cout << "DrawingNativePenTest Setup code called before each test case." << std::endl;
    OH_Drawing_ErrorCodeReset();
    std::cout << "DrawingNativePenTest errorCodeReset before each test case." << std::endl;
}

void DrawingNativePenTestTearDown()
{
    std::cout << "DrawingNativePenTest Setup code called after each test case." << std::endl;
    OH_Drawing_ErrorCodeReset();
    std::cout << "DrawingNativePenTest errorCodeReset after each test case." << std::endl;
}

/**
 * @tc.name   testPenCreateNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0100
 * @tc.desc   Test for testPenCreateNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenCreateNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Free the memory using OH_Drawing_PenDestroy
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenCopyNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0200
 * @tc.desc   Test for testPenCopyNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenCopyNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object 1 using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen1 = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen1, nullptr);
    // 2. Set color for pen 1 using OH_Drawing_PenSetColor
    OH_Drawing_PenSetColor(pen1, TEST_PEN_COLOR_BLACK);
    // 3. Copy pen 1 to pen 2 using OH_Drawing_PenCopy
    OH_Drawing_Pen* pen2 = OH_Drawing_PenCopy(pen1);
    // add assert
    EXPECT_NE(pen2, nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    // 4. Get color of pen 2 using OH_Drawing_PenGetColor
    uint32_t color = OH_Drawing_PenGetColor(pen2);
    EXPECT_EQ(color, TEST_PEN_COLOR_BLACK);
    // 5. Modify color of pen 1 using OH_Drawing_PenSetColor
    OH_Drawing_PenSetColor(pen1, TEST_PEN_COLOR_RED);
    // 6. Get color of pen 2 using OH_Drawing_PenGetColor
    uint32_t color2 = OH_Drawing_PenGetColor(pen2);
    EXPECT_EQ(color2, TEST_PEN_COLOR_BLACK);
    // 7. Free the memory
    OH_Drawing_PenDestroy(pen1);
    OH_Drawing_PenDestroy(pen2);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenCopyNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0300
 * @tc.desc   Test for testPenCopyNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenCopyNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Copy pen object with nullptr using OH_Drawing_PenCopy
    OH_Drawing_Pen* pen2 = OH_Drawing_PenCopy(nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    OH_Drawing_PenDestroy(pen2);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenCopyInputDestroyed
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0400
 * @tc.desc   Test for testPenCopyInputDestroyed.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenCopyInputDestroyed()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object 1 using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen1 = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen1, nullptr);
    // 2. Copy pen 1 to pen 2 using OH_Drawing_PenCopy
    OH_Drawing_Pen* pen2 = OH_Drawing_PenCopy(pen1);
    // add assert
    EXPECT_NE(pen2, nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    // 3. Destroy pen 1 using OH_Drawing_PenDestroy
    OH_Drawing_PenDestroy(pen1);
    // 4. Set color for pen 2 using OH_Drawing_PenSetColor
    OH_Drawing_PenSetColor(pen2, TEST_PEN_COLOR_BLACK);
    // 5. Get color of pen 2 using OH_Drawing_PenGetColor
    uint32_t color = OH_Drawing_PenGetColor(pen2);
    EXPECT_EQ(color, TEST_PEN_COLOR_BLACK);
    // 6. Free the memory
    OH_Drawing_PenDestroy(pen2);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenDestroyNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0500
 * @tc.desc   Test for testPenDestroyNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenDestroyNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Destroy the object using OH_Drawing_PenDestroy
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenDestroyNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0600
 * @tc.desc   Test for testPenDestroyNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenDestroyNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Destroy the object with nullptr using OH_Drawing_PenDestroy
    OH_Drawing_PenDestroy(nullptr);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenIsAntiAliasNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0700
 * @tc.desc   Test for testPenIsAntiAliasNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenIsAntiAliasNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set anti-aliasing for the pen using OH_Drawing_PenSetAntiAlias
    OH_Drawing_PenSetAntiAlias(pen, true);
    // 3. Get the anti-aliasing status of the pen using OH_Drawing_PenIsAntiAlias
    bool isAntiAlias = OH_Drawing_PenIsAntiAlias(pen);
    EXPECT_EQ(isAntiAlias, true);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenIsAntiAliasNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0800
 * @tc.desc   Test for testPenIsAntiAliasNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenIsAntiAliasNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenIsAntiAlias with nullptr as parameter
    bool isAntiAlias = OH_Drawing_PenIsAntiAlias(nullptr);
    EXPECT_EQ(isAntiAlias, false);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetAntiAliasNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_0900
 * @tc.desc   Test for testPenSetAntiAliasNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetAntiAliasNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set anti-aliasing for the pen using OH_Drawing_PenSetAntiAlias
    OH_Drawing_PenSetAntiAlias(pen, true);
    // 3. Get the anti-aliasing status of the pen using OH_Drawing_PenIsAntiAlias
    bool isAntiAlias = OH_Drawing_PenIsAntiAlias(pen);
    EXPECT_EQ(isAntiAlias, true);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetAntiAliasNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01000
 * @tc.desc   Test for testPenSetAntiAliasNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetAntiAliasNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set anti-aliasing for the pen using OH_Drawing_PenSetAntiAlias
    OH_Drawing_PenSetAntiAlias(nullptr, true);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetColorNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01100
 * @tc.desc   Test for testPenGetColorNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetColorNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set color for the pen using OH_Drawing_PenSetColor
    OH_Drawing_PenSetColor(pen, TEST_PEN_COLOR_BLACK);
    // 3. Get color of the pen using OH_Drawing_PenGetColor
    uint32_t color = OH_Drawing_PenGetColor(pen);
    EXPECT_EQ(color, TEST_PEN_COLOR_BLACK);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetColorNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01200
 * @tc.desc   Test for testPenGetColorNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetColorNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenGetColor with nullptr as parameter
    OH_Drawing_PenGetColor(nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetColorNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01300
 * @tc.desc   Test for testPenSetColorNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetColorNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set color for the pen using OH_Drawing_PenSetColor
    OH_Drawing_PenSetColor(pen, TEST_PEN_COLOR_BLACK);
    // 3. Get color of the pen using OH_Drawing_PenGetColor
    uint32_t color = OH_Drawing_PenGetColor(pen);
    EXPECT_EQ(color, TEST_PEN_COLOR_BLACK);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetColorNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01400
 * @tc.desc   Test for testPenSetColorNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetColorNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set color for the pen using OH_Drawing_PenSetColor with nullptr as the first parameter
    OH_Drawing_PenSetColor(nullptr, TEST_PEN_COLOR_BLACK);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Set color for the pen using OH_Drawing_PenSetColor with TEST_PEN_COLOR_BLACK as the second parameter
    OH_Drawing_PenSetColor(pen, TEST_PEN_COLOR_BLACK);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetColorAbnormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01500
 * @tc.desc   Test for testPenSetColorAbnormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetColorAbnormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the second parameter of OH_Drawing_PenSetColor to a negative number or a floating-point number
    OH_Drawing_PenSetColor(pen, TEST_PEN_NEGATIVE_1);
    // 3. Call OH_Drawing_PenGetColor
    uint32_t color = OH_Drawing_PenGetColor(pen);
    EXPECT_EQ(static_cast<uint32_t>(TEST_PEN_NEGATIVE_1), color);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetColorMaximum
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01600
 * @tc.desc   Test for testPenSetColorMaximum.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetColorMaximum()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the second parameter of OH_Drawing_PenSetColor to a maximum value of TEST_PEN_COLOR_MAX + 1
    OH_Drawing_PenSetColor(pen, TEST_PEN_COLOR_MAX + 1);
    // 3. Get the color of the pen using OH_Drawing_PenGetColor
    uint32_t color = OH_Drawing_PenGetColor(pen);
    EXPECT_EQ(TEST_PEN_COLOR_MAX + 1, color);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetAlphaNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01700
 * @tc.desc   Test for testPenGetAlphaNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetAlphaNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the alpha value for the pen using OH_Drawing_PenSetAlpha
    OH_Drawing_PenSetAlpha(pen, TEST_PEN_ALPHA_0);
    // 3. Get the alpha value of the pen using OH_Drawing_PenGetAlpha
    uint8_t alpha = OH_Drawing_PenGetAlpha(pen);
    EXPECT_EQ(alpha, TEST_PEN_ALPHA_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetAlphaNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01800
 * @tc.desc   Test for testPenGetAlphaNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetAlphaNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenGetAlpha with nullptr as parameter
    OH_Drawing_PenGetAlpha(nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetAlphaNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_01900
 * @tc.desc   Test for testPenSetAlphaNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetAlphaNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the alpha value for the pen using OH_Drawing_PenSetAlpha
    OH_Drawing_PenSetAlpha(pen, TEST_PEN_ALPHA_0);
    // 3. Get the alpha value of the pen using OH_Drawing_PenGetAlpha
    uint8_t alpha = OH_Drawing_PenGetAlpha(pen);
    EXPECT_EQ(alpha, TEST_PEN_ALPHA_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetAlphaNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02000
 * @tc.desc   Test for testPenSetAlphaNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetAlphaNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the alpha value for the pen using OH_Drawing_PenSetAlpha with nullptr as the first parameter
    OH_Drawing_PenSetAlpha(nullptr, TEST_PEN_ALPHA_255);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Set the alpha value for the pen using OH_Drawing_PenSetAlpha with TEST_PEN_ALPHA_0 as the second parameter
    OH_Drawing_PenSetAlpha(pen, TEST_PEN_ALPHA_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetAlphaAbnormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02100
 * @tc.desc   Test for testPenSetAlphaAbnormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetAlphaAbnormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the second parameter of OH_Drawing_PenSetAlpha to a negative number or a floating-point number
    OH_Drawing_PenSetAlpha(pen, TEST_PEN_NEGATIVE_1);
    // 3. Call OH_Drawing_PenGetAlpha
    uint8_t alpha = OH_Drawing_PenGetAlpha(pen);
    EXPECT_EQ(static_cast<uint8_t>(TEST_PEN_NEGATIVE_1), alpha);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetAlphaMaximum
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02200
 * @tc.desc   Test for testPenSetAlphaMaximum.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetAlphaMaximum()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the second parameter of OH_Drawing_PenSetAlpha to a maximum value of TEST_PEN_ALPHA_255 + 1
    uint8_t alpha1 = TEST_PEN_ALPHA_255;
    OH_Drawing_PenSetAlpha(pen, alpha1 + 1);
    // 3. Call OH_Drawing_PenGetAlpha
    uint8_t alpha2 = OH_Drawing_PenGetAlpha(pen);
    EXPECT_EQ(alpha2, 0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetWidthNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02300
 * @tc.desc   Test for testPenGetWidthNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetWidthNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the pen width using OH_Drawing_PenSetWidth
    OH_Drawing_PenSetWidth(pen, TEST_PEN_WIDTH_1_0);
    // 3. Get the pen width using OH_Drawing_PenGetWidth
    float width = OH_Drawing_PenGetWidth(pen);
    EXPECT_EQ(width, TEST_PEN_WIDTH_1_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetWidthNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02400
 * @tc.desc   Test for testPenGetWidthNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetWidthNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenGetWidth with nullptr as parameter
    OH_Drawing_PenGetWidth(nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetWidthBoundary
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02500
 * @tc.desc   Test for testPenGetWidthBoundary.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetWidthBoundary()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the pen width using OH_Drawing_PenSetWidth
    float width = TEST_PEN_WIDTH_4096_0;
    OH_Drawing_PenSetWidth(pen, width);
    // 3. Get the pen width using OH_Drawing_PenGetWidth
    float getWidth = OH_Drawing_PenGetWidth(pen);
    EXPECT_EQ(width, getWidth);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetWidthNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02600
 * @tc.desc   Test for testPenSetWidthNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetWidthNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the pen width using OH_Drawing_PenSetWidth
    OH_Drawing_PenSetWidth(pen, TEST_PEN_WIDTH_1_0);
    // 3. Get the pen width using OH_Drawing_PenGetWidth
    float width = OH_Drawing_PenGetWidth(pen);
    EXPECT_EQ(width, TEST_PEN_WIDTH_1_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetWidthNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02700
 * @tc.desc   Test for testPenSetWidthNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetWidthNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenSetWidth with nullptr as the first parameter
    OH_Drawing_PenSetWidth(nullptr, TEST_PEN_WIDTH_1_0);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Call OH_Drawing_PenSetWidth with TEST_PEN_VALUE_0_0 as the second parameter
    OH_Drawing_PenSetWidth(pen, TEST_PEN_VALUE_0_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetWidthAbnormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02800
 * @tc.desc   Test for testPenSetWidthAbnormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetWidthAbnormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the pen width using OH_Drawing_PenSetWidth with an integer or character data as the second parameter
    int width = static_cast<int>(TEST_PEN_WIDTH_1_0);
    OH_Drawing_PenSetWidth(pen, width);
    // 3. Get the pen width using OH_Drawing_PenGetWidth
    float width2 = OH_Drawing_PenGetWidth(pen);
    EXPECT_EQ(static_cast<float>(TEST_PEN_WIDTH_1_0), width2);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetWidthMultipleCalls
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_02900
 * @tc.desc   Test for testPenSetWidthMultipleCalls.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetWidthMultipleCalls()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Loop through 10 times and set the pen width using OH_Drawing_PenSetWidth
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenSetWidth(pen, TEST_PEN_WIDTH_1_0);
    }
    // 3. Loop through 10 times and get the pen width using OH_Drawing_PenGetWidth
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        float width = OH_Drawing_PenGetWidth(pen);
        EXPECT_EQ(width, TEST_PEN_WIDTH_1_0);
    }
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetWidthMultipleCallsBoundary
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03000
 * @tc.desc   Test for testPenSetWidthMultipleCallsBoundary.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetWidthMultipleCallsBoundary()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Loop through 10 times and set the pen width using OH_Drawing_PenSetWidth
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenSetWidth(pen, TEST_PEN_WIDTH_4096_0);
    }
    // 3. Loop through 10 times and get the pen width using OH_Drawing_PenGetWidth
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        float width = OH_Drawing_PenGetWidth(pen);
        EXPECT_EQ(width, TEST_PEN_WIDTH_4096_0);
    }
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetMiterLimitNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03100
 * @tc.desc   Test for testPenGetMiterLimitNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetMiterLimitNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the miter limit for the pen using OH_Drawing_PenSetMiterLimit
    OH_Drawing_PenSetMiterLimit(pen, TEST_PEN_MITER_LIMIT_1_0);
    // 3. Get the miter limit using OH_Drawing_PenGetMiterLimit
    float miterLimit = OH_Drawing_PenGetMiterLimit(pen);
    EXPECT_EQ(miterLimit, TEST_PEN_MITER_LIMIT_1_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetMiterLimitNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03200
 * @tc.desc   Test for testPenGetMiterLimitNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetMiterLimitNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenGetMiterLimit with nullptr as parameter
    OH_Drawing_PenGetMiterLimit(nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetMiterLimitNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03300
 * @tc.desc   Test for testPenSetMiterLimitNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetMiterLimitNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the miter limit for the pen using OH_Drawing_PenSetMiterLimit
    OH_Drawing_PenSetMiterLimit(pen, TEST_PEN_MITER_LIMIT_1_0);
    // 3. Get the miter limit using OH_Drawing_PenGetMiterLimit
    float miterLimit = OH_Drawing_PenGetMiterLimit(pen);
    EXPECT_EQ(miterLimit, TEST_PEN_MITER_LIMIT_1_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetMiterLimitNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03400
 * @tc.desc   Test for testPenSetMiterLimitNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetMiterLimitNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenSetMiterLimit with nullptr as the first parameter
    OH_Drawing_PenSetMiterLimit(nullptr, TEST_PEN_MITER_LIMIT_1_0);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Call OH_Drawing_PenSetMiterLimit with TEST_PEN_MITER_LIMIT_0_0 as the second parameter
    OH_Drawing_PenSetMiterLimit(pen, TEST_PEN_MITER_LIMIT_0_0);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetMiterLimitAbnormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03500
 * @tc.desc   Test for testPenSetMiterLimitAbnormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetMiterLimitAbnormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the miter limit for the pen using OH_Drawing_PenSetMiterLimit with an integer or character data as the
    // second parameter
    int miterLimit = static_cast<int>(TEST_PEN_MITER_LIMIT_1_0);
    OH_Drawing_PenSetMiterLimit(pen, miterLimit);
    // 3. Get the miter limit using OH_Drawing_PenGetMiterLimit
    float miterLimit2 = OH_Drawing_PenGetMiterLimit(pen);
    EXPECT_EQ(static_cast<float>(TEST_PEN_MITER_LIMIT_1_0), miterLimit2);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetMiterLimitMultipleCalls
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03600
 * @tc.desc   Test for testPenSetMiterLimitMultipleCalls.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetMiterLimitMultipleCalls()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Loop through 10 times and set the miter limit for the pen using OH_Drawing_PenSetMiterLimit
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenSetMiterLimit(pen, TEST_PEN_MITER_LIMIT_1_0);
    }
    // 3. Loop through 10 times and get the miter limit using OH_Drawing_PenGetMiterLimit
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenGetMiterLimit(pen);
    }
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetCapNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03700
 * @tc.desc   Test for testPenGetCapNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetCapNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the pen cap style using OH_Drawing_PenSetCap
    OH_Drawing_PenSetCap(pen, LINE_FLAT_CAP);
    // 3. Get the pen cap style using OH_Drawing_PenGetCap
    OH_Drawing_PenLineCapStyle cap = OH_Drawing_PenGetCap(pen);
    EXPECT_EQ(cap, LINE_FLAT_CAP);

    OH_Drawing_PenSetCap(pen, LINE_SQUARE_CAP);
    cap = OH_Drawing_PenGetCap(pen);
    EXPECT_EQ(cap, LINE_SQUARE_CAP);

    OH_Drawing_PenSetCap(pen, LINE_ROUND_CAP);
    cap = OH_Drawing_PenGetCap(pen);
    EXPECT_EQ(cap, LINE_ROUND_CAP);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetCapNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03800
 * @tc.desc   Test for testPenGetCapNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetCapNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenGetCap with nullptr as parameter
    OH_Drawing_PenGetCap(nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetCapNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_03900
 * @tc.desc   Test for testPenSetCapNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetCapNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenSetCap with the second parameter as an enumeration by looping through the styles array
    OH_Drawing_PenLineCapStyle styles[] = { LINE_FLAT_CAP, LINE_SQUARE_CAP, LINE_ROUND_CAP };
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_STYLE_COUNT_3; i++) {
        OH_Drawing_PenSetCap(pen, styles[i]);
        // 3. Get the pen cap style using OH_Drawing_PenGetCap
        OH_Drawing_PenLineCapStyle cap = OH_Drawing_PenGetCap(pen);
        EXPECT_EQ(cap, styles[i]);
    }
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetCapNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04000
 * @tc.desc   Test for testPenSetCapNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetCapNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenSetCap with nullptr as the first parameter
    OH_Drawing_PenSetCap(nullptr, LINE_FLAT_CAP);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetCapMultipleCalls
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04100
 * @tc.desc   Test for testPenSetCapMultipleCalls.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetCapMultipleCalls()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Loop through 10 times and set the pen cap style using OH_Drawing_PenSetCap
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenSetCap(pen, LINE_FLAT_CAP);
    }
    // 3. Loop through 10 times and get the pen cap style using OH_Drawing_PenGetCap
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenGetCap(pen);
    }
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetJoinNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04200
 * @tc.desc   Test for testPenGetJoinNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetJoinNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the join style for the pen using OH_Drawing_PenSetJoin
    OH_Drawing_PenSetJoin(pen, LINE_MITER_JOIN);
    // 3. Get the join style using OH_Drawing_PenGetJoin
    OH_Drawing_PenLineJoinStyle join = OH_Drawing_PenGetJoin(pen);
    EXPECT_EQ(join, LINE_MITER_JOIN);

    OH_Drawing_PenSetJoin(pen, LINE_ROUND_JOIN);
    join = OH_Drawing_PenGetJoin(pen);
    EXPECT_EQ(join, LINE_ROUND_JOIN);

    OH_Drawing_PenSetJoin(pen, LINE_BEVEL_JOIN);
    join = OH_Drawing_PenGetJoin(pen);
    EXPECT_EQ(join, LINE_BEVEL_JOIN);
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetJoinNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04300
 * @tc.desc   Test for testPenGetJoinNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetJoinNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenGetJoin with nullptr as parameter
    OH_Drawing_PenGetJoin(nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetJoinNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04400
 * @tc.desc   test for testPenSetJoinNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetJoinNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenSetJoin with the second parameter as an enumeration by looping through the styles array
    OH_Drawing_PenLineJoinStyle styles[] = { LINE_MITER_JOIN, LINE_ROUND_JOIN, LINE_BEVEL_JOIN };
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_STYLE_COUNT_3; i++) {
        OH_Drawing_PenSetJoin(pen, styles[i]);
        // 3. Get the join style using OH_Drawing_PenGetJoin
        OH_Drawing_PenLineJoinStyle join = OH_Drawing_PenGetJoin(pen);
        EXPECT_EQ(join, styles[i]);
    }
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetJoinNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04500
 * @tc.desc   test for testPenSetJoinNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetJoinNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenSetJoin with nullptr as the first parameter
    OH_Drawing_PenSetJoin(nullptr, LINE_MITER_JOIN);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetJoinMultipleCalls
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04600
 * @tc.desc   test for testPenSetJoinMultipleCalls.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetJoinMultipleCalls()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Loop through 10 times and set the pen join style using OH_Drawing_PenSetJoin
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenSetJoin(pen, LINE_MITER_JOIN);
    }
    // 3. Loop through 10 times and get the pen join style using OH_Drawing_PenGetJoin
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenGetJoin(pen);
    }
    // 4. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetShaderEffectNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04700
 * @tc.desc   test for testPenSetShaderEffectNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetShaderEffectNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a shader object using OH_Drawing_ShaderEffectCreate
    OH_Drawing_Point* startPt = OH_Drawing_PointCreate(TEST_PEN_POINT_X_100, TEST_PEN_POINT_Y_400);
    // add assert
    EXPECT_NE(startPt, nullptr);
    OH_Drawing_Point* endPt = OH_Drawing_PointCreate(TEST_PEN_POINT_X_200, TEST_PEN_POINT_Y_500);
    // add assert
    EXPECT_NE(endPt, nullptr);
    uint32_t color[] = { TEST_PEN_COLOR_RED, TEST_PEN_COLOR_GREEN };
    float pos[] = { TEST_PEN_POS_0_0, TEST_PEN_POS_1_0 };
    OH_Drawing_ShaderEffect* linearGradient =
        OH_Drawing_ShaderEffectCreateLinearGradient(startPt, endPt, color, pos, TEST_PEN_COLOR_COUNT_2,
                                                    OH_Drawing_TileMode::CLAMP);
    // add assert
    EXPECT_NE(linearGradient, nullptr);
    // 3. Set the shader effect for the pen using OH_Drawing_PenSetShaderEffect
    OH_Drawing_PenSetShaderEffect(pen, linearGradient);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    // 4. Free the memory
    OH_Drawing_PointDestroy(startPt);
    OH_Drawing_PointDestroy(endPt);
    OH_Drawing_ShaderEffectDestroy(linearGradient);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetShaderEffectNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04800
 * @tc.desc   test for testPenSetShaderEffectNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetShaderEffectNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a shader object using OH_Drawing_ShaderEffectCreate
    OH_Drawing_Point* startPt = OH_Drawing_PointCreate(TEST_PEN_POINT_X_100, TEST_PEN_POINT_Y_400);
    // add assert
    EXPECT_NE(startPt, nullptr);
    OH_Drawing_Point* endPt = OH_Drawing_PointCreate(TEST_PEN_POINT_X_200, TEST_PEN_POINT_Y_500);
    // add assert
    EXPECT_NE(endPt, nullptr);
    uint32_t color[] = { TEST_PEN_COLOR_RED, TEST_PEN_COLOR_GREEN };
    float pos[] = { TEST_PEN_POS_0_0, TEST_PEN_POS_1_0 };
    OH_Drawing_ShaderEffect* linearGradient =
        OH_Drawing_ShaderEffectCreateLinearGradient(startPt, endPt, color, pos, TEST_PEN_COLOR_COUNT_2,
                                                    OH_Drawing_TileMode::CLAMP);
    // add assert
    EXPECT_NE(linearGradient, nullptr);
    // 3. Call OH_Drawing_PenSetShaderEffect with nullptr as the first parameter
    OH_Drawing_PenSetShaderEffect(nullptr, linearGradient);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 4. Call OH_Drawing_PenSetShaderEffect with nullptr as the second parameter
    OH_Drawing_PenSetShaderEffect(pen, nullptr);
    // 5. Free the memory
    OH_Drawing_PointDestroy(startPt);
    OH_Drawing_PointDestroy(endPt);
    OH_Drawing_ShaderEffectDestroy(linearGradient);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetShadowLayerNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_04900
 * @tc.desc   test for testPenSetShadowLayerNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetShadowLayerNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a shadow layer object using OH_Drawing_ShadowLayerCreate
    OH_Drawing_ShadowLayer* shadowLayer = OH_Drawing_ShadowLayerCreate(
        TEST_PEN_SHADOW_OFFSET_X_10, TEST_PEN_SHADOW_OFFSET_Y_10,
        TEST_PEN_SHADOW_BLUR_RADIUS_10, TEST_PEN_COLOR_BLACK_ALPHA);
    // add assert
    EXPECT_NE(shadowLayer, nullptr);
    // 3. Set the shadow layer for the pen using OH_Drawing_PenSetShadowLayer
    OH_Drawing_PenSetShadowLayer(pen, shadowLayer);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    // 4. Free the memory
    OH_Drawing_ShadowLayerDestroy(shadowLayer);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetShadowLayerNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05000
 * @tc.desc   test for testPenSetShadowLayerNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetShadowLayerNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a shadow layer object using OH_Drawing_ShadowLayerCreate
    OH_Drawing_ShadowLayer* shadowLayer = OH_Drawing_ShadowLayerCreate(
        TEST_PEN_SHADOW_OFFSET_X_10, TEST_PEN_SHADOW_OFFSET_Y_10,
        TEST_PEN_SHADOW_BLUR_RADIUS_10, TEST_PEN_COLOR_BLACK_ALPHA);
    // add assert
    EXPECT_NE(shadowLayer, nullptr);
    // 3. Set the shadow layer for the pen using OH_Drawing_PenSetShadowLayer with nullptr as the first parameter
    OH_Drawing_PenSetShadowLayer(nullptr, shadowLayer);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 4. Set the shadow layer for the pen using OH_Drawing_PenSetShadowLayer with nullptr as the second parameter
    OH_Drawing_PenSetShadowLayer(pen, nullptr);
    // 5. Free the memory
    OH_Drawing_ShadowLayerDestroy(shadowLayer);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetFilterNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05100
 * @tc.desc   test for testPenSetFilterNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetFilterNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a filter object using OH_Drawing_FilterCreate
    OH_Drawing_Filter* filter = OH_Drawing_FilterCreate();
    // add assert
    EXPECT_NE(filter, nullptr);
    // 3. Set the filter effect for the pen using OH_Drawing_PenSetFilter
    OH_Drawing_PenSetFilter(pen, filter);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    // 4. Get the filter effect for the pen using OH_Drawing_PenGetFilter
    OH_Drawing_Filter* filter2 = OH_Drawing_FilterCreate();
    // add assert
    EXPECT_NE(filter2, nullptr);
    OH_Drawing_PenGetFilter(pen, filter2);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    // 5. Free the memory
    OH_Drawing_FilterDestroy(filter);
    OH_Drawing_FilterDestroy(filter2);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetFilterNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05200
 * @tc.desc   test for testPenSetFilterNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetFilterNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a filter object using OH_Drawing_FilterCreate
    OH_Drawing_Filter* filter = OH_Drawing_FilterCreate();
    // add assert
    EXPECT_NE(filter, nullptr);
    // 3. Call OH_Drawing_PenSetFilter with nullptr as the first parameter
    OH_Drawing_PenSetFilter(nullptr, filter);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 4. Call OH_Drawing_PenSetFilter with nullptr as the second parameter
    OH_Drawing_PenSetFilter(pen, nullptr);
    // 5. Free the memory
    OH_Drawing_FilterDestroy(filter);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetFilterNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05300
 * @tc.desc   test for testPenGetFilterNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetFilterNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a filter object using OH_Drawing_FilterCreate
    OH_Drawing_Filter* filter = OH_Drawing_FilterCreate();
    // add assert
    EXPECT_NE(filter, nullptr);
    // 3. Set the filter effect for the pen using OH_Drawing_PenSetFilter
    OH_Drawing_PenSetFilter(pen, filter);
    // 4. Get the filter effect for the pen using OH_Drawing_PenGetFilter
    OH_Drawing_Filter* filter2 = OH_Drawing_FilterCreate();
    // add assert
    EXPECT_NE(filter2, nullptr);
    OH_Drawing_PenGetFilter(pen, filter2);
    // 5. Free the memory
    OH_Drawing_FilterDestroy(filter);
    OH_Drawing_FilterDestroy(filter2);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetFilterNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05400
 * @tc.desc   test for testPenGetFilterNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetFilterNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a filter object using OH_Drawing_FilterCreate
    OH_Drawing_Filter* filter = OH_Drawing_FilterCreate();
    // add assert
    EXPECT_NE(filter, nullptr);
    // 3. Call OH_Drawing_PenGetFilter with nullptr as the first parameter
    OH_Drawing_PenGetFilter(nullptr, filter);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    OH_Drawing_ErrorCodeReset();
    // 4. Call OH_Drawing_PenGetFilter with nullptr as the second parameter
    OH_Drawing_PenGetFilter(pen, nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 5. Free the memory
    OH_Drawing_FilterDestroy(filter);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetBlendModeNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05500
 * @tc.desc   test for testPenSetBlendModeNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenSetBlendModeNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Use a loop to iterate through the enum values of OH_Drawing_BlendMode and call OH_Drawing_PenSetBlendMode with
    // the second parameter
    OH_Drawing_BlendMode modes[] = { BLEND_MODE_CLEAR, BLEND_MODE_SRC, BLEND_MODE_DST };
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_STYLE_COUNT_3; i++) {
        OH_Drawing_ErrorCodeReset();
        OH_Drawing_PenSetBlendMode(pen, modes[i]);
        // add assert
        EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    }
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenSetBlendModeNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05600
 * @tc.desc   test for testPenSetBlendModeNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenSetBlendModeNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenSetBlendMode with nullptr as the first parameter
    OH_Drawing_PenSetBlendMode(nullptr, BLEND_MODE_CLEAR);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetFillPathNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05700
 * @tc.desc   test for testPenGetFillPathNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenGetFillPathNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    float penWidth = TEST_PEN_WIDTH_10_0;
    OH_Drawing_PenSetWidth(pen, penWidth);
    // 2. Create a source path object using OH_Drawing_PathCreate
    OH_Drawing_Path* srcPath = OH_Drawing_PathCreate();
    // add assert
    EXPECT_NE(srcPath, nullptr);
    OH_Drawing_PathMoveTo(srcPath, TEST_PEN_POINT_X_50, TEST_PEN_POINT_Y_50);
    OH_Drawing_PathLineTo(srcPath, TEST_PEN_POINT_X_100, TEST_PEN_POINT_Y_50);
    OH_Drawing_PathLineTo(srcPath, TEST_PEN_POINT_X_100, TEST_PEN_POINT_Y_100);
    OH_Drawing_PathClose(srcPath);
    // 3. Create a destination path object using OH_Drawing_PathCreate
    OH_Drawing_Path* dstPath = OH_Drawing_PathCreate();
    // add assert
    EXPECT_NE(dstPath, nullptr);
    // 4. Create a rectangle object using OH_Drawing_RectCreate
    OH_Drawing_Rect* rect = OH_Drawing_RectCreate(
        TEST_PEN_RECT_LEFT_100, TEST_PEN_RECT_TOP_100,
        TEST_PEN_RECT_RIGHT_200, TEST_PEN_RECT_BOTTOM_200);
    // add assert
    EXPECT_NE(rect, nullptr);
    // 5. Create a matrix object using OH_Drawing_MatrixCreate
    OH_Drawing_Matrix* matrix = OH_Drawing_MatrixCreate();
    // add assert
    EXPECT_NE(matrix, nullptr);
    // 6. Call OH_Drawing_PenGetFillPath
    bool isSuccess = OH_Drawing_PenGetFillPath(pen, srcPath, dstPath, rect, matrix);
    // add assert
    EXPECT_EQ(isSuccess, true);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    // 7. Free the memory
    OH_Drawing_PathDestroy(srcPath);
    OH_Drawing_PathDestroy(dstPath);
    OH_Drawing_RectDestroy(rect);
    OH_Drawing_MatrixDestroy(matrix);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetFillPathNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05800
 * @tc.desc   test for testPenGetFillPathNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetFillPathNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Create a source path object using OH_Drawing_PathCreate
    OH_Drawing_Path* srcPath = OH_Drawing_PathCreate();
    // add assert
    EXPECT_NE(srcPath, nullptr);
    // 3. Create a destination path object using OH_Drawing_PathCreate
    OH_Drawing_Path* dstPath = OH_Drawing_PathCreate();
    // add assert
    EXPECT_NE(dstPath, nullptr);
    // 4. Create a rectangle object using OH_Drawing_RectCreate
    OH_Drawing_Rect* rect = OH_Drawing_RectCreate(
        TEST_PEN_RECT_LEFT_100, TEST_PEN_RECT_TOP_100, TEST_PEN_RECT_RIGHT_200, TEST_PEN_RECT_BOTTOM_200);
    // add assert
    EXPECT_NE(rect, nullptr);
    // 5. Create a matrix object using OH_Drawing_MatrixCreate
    OH_Drawing_Matrix* matrix = OH_Drawing_MatrixCreate();
    // add assert
    EXPECT_NE(matrix, nullptr);
    // 6. Call OH_Drawing_PenGetFillPath with nullptr as the first parameter
    bool isSuccess = OH_Drawing_PenGetFillPath(nullptr, srcPath, dstPath, rect, matrix);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    EXPECT_EQ(isSuccess, false);
    OH_Drawing_ErrorCodeReset();
    // 7. Call OH_Drawing_PenGetFillPath with nullptr as the second parameter
    isSuccess = OH_Drawing_PenGetFillPath(pen, nullptr, dstPath, rect, matrix);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    EXPECT_EQ(isSuccess, false);
    OH_Drawing_ErrorCodeReset();
    // 8. Call OH_Drawing_PenGetFillPath with nullptr as the third parameter
    isSuccess = OH_Drawing_PenGetFillPath(pen, srcPath, nullptr, rect, matrix);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    EXPECT_EQ(isSuccess, false);
    // 9. Call OH_Drawing_PenGetFillPath with nullptr as the fourth parameter
    isSuccess = OH_Drawing_PenGetFillPath(pen, srcPath, dstPath, nullptr, matrix);
    // add assert
    EXPECT_EQ(isSuccess, false);
    // 10. Call OH_Drawing_PenGetFillPath with nullptr as the fifth parameter
    isSuccess = OH_Drawing_PenGetFillPath(pen, srcPath, dstPath, rect, nullptr);
    // add assert
    EXPECT_EQ(isSuccess, false);
    // 11. Free the memory
    OH_Drawing_PathDestroy(srcPath);
    OH_Drawing_PathDestroy(dstPath);
    OH_Drawing_RectDestroy(rect);
    OH_Drawing_MatrixDestroy(matrix);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenResetNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_05900
 * @tc.desc   test for testPenResetNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL0
 */
int TestPenResetNormal()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Set the pen color using OH_Drawing_PenSetColor
    OH_Drawing_PenSetColor(pen, TEST_PEN_COLOR_BLUE);
    // 3. Get the pen color using OH_Drawing_PenGetColor
    uint32_t color = OH_Drawing_PenGetColor(pen);
    EXPECT_EQ(TEST_PEN_COLOR_BLUE, color);
    // 4. Reset the pen state using OH_Drawing_PenReset
    OH_Drawing_PenReset(pen);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_SUCCESS);
    // 5. Get the pen color using OH_Drawing_PenGetColor
    color = OH_Drawing_PenGetColor(pen);
    OH_Drawing_Pen* pen2 = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen2, nullptr);
    uint32_t color2 = OH_Drawing_PenGetColor(pen2);
    EXPECT_EQ(color2, color);
    // 6. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenResetNull
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_06000
 * @tc.desc   test for testPenResetNull.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenResetNull()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Call OH_Drawing_PenReset with nullptr as the parameter
    OH_Drawing_PenReset(nullptr);
    // add assert
    EXPECT_EQ(OH_Drawing_ErrorCodeGet(), OH_Drawing_ErrorCode::OH_DRAWING_ERROR_INVALID_PARAMETER);
    // 3. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenResetMultipleCalls
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_06100
 * @tc.desc   test for testPenResetMultipleCalls.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenResetMultipleCalls()
{
    DrawingNativePenTestSetUp();
    // 1. Create a pen object using OH_Drawing_PenCreate
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    // add assert
    EXPECT_NE(pen, nullptr);
    // 2. Use a loop to call OH_Drawing_PenSetColor and set the pen color 10 times
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenSetColor(pen, TEST_PEN_COLOR_BLUE);
    }
    // 3. Use a loop to call OH_Drawing_PenGetColor and get the pen color 10 times
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenGetColor(pen);
    }
    // 4. Use a loop to call OH_Drawing_PenReset and reset the pen state 10 times
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenReset(pen);
    }
    // 5. Use a loop to call OH_Drawing_PenGetColor and get the pen color 10 times
    for (int i = TEST_PEN_ARRAY_INDEX_0; i < TEST_PEN_LOOP_COUNT_10; i++) {
        OH_Drawing_PenGetColor(pen);
    }
    // 6. Free the memory
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}

/**
 * @tc.name   testPenGetAlphaFloatNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_06200
 * @tc.desc   test for testPenGetAlphaFloatNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL2
 */
int TestPenGetAlphaFloatNormal()
{
    DrawingNativePenTestSetUp();
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    float a = PEN_F_0_0;
    OH_Drawing_PenSetWidth(pen, TEST_PEN_WIDTH_10_0);
    OH_Drawing_PenSetColor4f(pen, PEN_F_1_0, PEN_F_0_4,
        PEN_G_1, PEN_B_0_2, nullptr);
    EXPECT_EQ(OH_Drawing_PenGetAlphaFloat(pen, &a), OH_DRAWING_SUCCESS);
    EXPECT_EQ(a, PEN_F_1_0);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}
/**
 * @tc.name   testPenGetAlphaFloatAbnormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_06300
 * @tc.desc   test for testPenGetAlphaFloatAbnormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL3
 */
int TestPenGetAlphaFloatAbnormal()
{
    DrawingNativePenTestSetUp();
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    float a = 0.f;
    OH_Drawing_PenSetWidth(pen, TEST_PEN_WIDTH_10_0);
    OH_Drawing_PenSetColor4f(pen, PEN_F_1_0, PEN_F_0_4,
        PEN_G_1, PEN_B_0_2, nullptr);
    EXPECT_EQ(OH_Drawing_PenGetAlphaFloat(nullptr, &a), OH_DRAWING_ERROR_INVALID_PARAMETER);
    EXPECT_EQ(OH_Drawing_PenGetAlphaFloat(pen, 0), OH_DRAWING_ERROR_INVALID_PARAMETER);
    EXPECT_EQ(OH_Drawing_PenGetAlphaFloat(pen, NULL), OH_DRAWING_ERROR_INVALID_PARAMETER);
    EXPECT_EQ(a, PEN_F_0_0);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}
/**
 * @tc.name   testPenGetRedFloatNormal
 * @tc.number SUB_BASIC_GRAPHICS_SPECIAL_API_NATIVE_DRAWING_PEN_06400
 * @tc.desc   test for testPenGetRedFloatNormal.
 * @tc.type   FUNCTION
 * @tc.size   SMALLTEST
 * @tc.level  LEVEL2
 */
int TestPenGetRedFloatNormal()
{
    DrawingNativePenTestSetUp();
    OH_Drawing_Pen* pen = OH_Drawing_PenCreate();
    float r = PEN_F_0_0;
    OH_Drawing_PenSetWidth(pen, TEST_PEN_WIDTH_10_0);
    OH_Drawing_PenSetColor4f(pen, PEN_F_1_0, PEN_F_0_4,
        PEN_G_1, PEN_B_0_2, nullptr);
    EXPECT_EQ(OH_Drawing_PenGetRedFloat(pen, &r), OH_DRAWING_SUCCESS);
    EXPECT_EQ(r, PEN_F_0_4);
    OH_Drawing_PenDestroy(pen);
    DrawingNativePenTestTearDown();
    return OH_DRAWING_SUCCESS;
}
} // namespace Drawing
} // namespace Rosen
} // namespace OHOS