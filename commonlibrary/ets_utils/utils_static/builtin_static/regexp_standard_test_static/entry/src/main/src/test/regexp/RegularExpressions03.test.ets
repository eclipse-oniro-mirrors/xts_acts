/*
* Copyright (c) 2025 SwanLink (Jiangsu) Technology Development Co., LTD.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

import {
  afterAll,
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  expect,
  it,
  Level,
  Size,
  TestType
} from '../../../../hypium/index';
import Utils from '../Util.test';


interface ReplaceGroups {
  name: string;
  age: string;
}

export default function RegularExpressions03Test() {
  describe('RegularExpressions03Test', () => {
    // Defines a test suite. Two parameters are supported: test suite name and test suite function.
    beforeAll(() => {
      // Presets an action, which is performed only once before all test cases of the test suite start.
      // This API supports only one parameter: preset action function.
    })
    beforeEach(() => {
      await Utils.msSleep(20);
      // Presets an action, which is performed before each unit test case starts.
      // The number of execution times is the same as the number of test cases defined by **it**.
      // This API supports only one parameter: preset action function.
    })
    afterEach(() => {
      // Presets a clear action, which is performed after each unit test case ends.
      // The number of execution times is the same as the number of test cases defined by **it**.
      // This API supports only one parameter: clear action function.
    })
    afterAll(() => {
      // Presets a clear action, which is performed after all test cases of the test suite end.
      // This API supports only one parameter: clear action function.
    })

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_6600
     * @tc.name      testStringRegularMethodModuleTestCase0066
     * @tc.desc      Verify String.prototype.split() with a dynamically constructed regex from a string of separators.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0066", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str66: string = "a,b;c,d|e";
      const separators66: string = ",;|";
      const re66: RegExp = new RegExp(`[${separators66}]`);
      const result66: string[] = str66.split(re66);
      const expected: string[] = ["a", "b", "c", "d", "e"];
      const testPassed: boolean = result66.length === expected.length &&
      result66.every((v, i) => v === expected[i]);
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_6700
     * @tc.name      testStringRegularMethodModuleTestCase0067
     * @tc.desc      Verify String.prototype.match() with a positive lookahead assertion to extract number before ' apples'.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0067", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str67: string = "I have 3 apples and 5 oranges";
      const re67: RegExp = new RegExp('\\d+(?= apples)');
      const result67: undefined | String = str67.match(re67)?.[0] || "";
      const expected: string = "3";
      const testPassed: boolean = result67 === expected;
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_7000
     * @tc.name      testStringRegularMethodModuleTestCase0070
     * @tc.desc      Verify String.prototype.search() with a dynamically created RegExp from a keyword string.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0070", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str70: string = "The quick brown fox jumps over the lazy dog";
      const keyword70: string = "fox";
      const re70: RegExp = new RegExp(keyword70);
      const result70: number = str70.search(re70);
      const expected: number = 16;
      expect(result70).assertEqual(expected);
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_7300
     * @tc.name      testStringRegularMethodModuleTestCase0073
     * @tc.desc      Verify String.prototype.split() behavior is identical when using a regex literal /,/ vs a string separator ",".
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0073", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str73: string = "a,b,c,d";
      const result73: string[] = [
        str73.split(new RegExp(',')).join("|"),
        str73.split(",").join("|")
      ];
      const expected: string[] = ["a|b|c|d", "a|b|c|d"];
      const testPassed: boolean = result73.length === expected.length &&
      result73.every((v, i) => v === expected[i]);
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_7400
     * @tc.name      testStringRegularMethodModuleTestCase0074
     * @tc.desc      Verify String.prototype.split() with a global regex and a limit parameter to restrict the number of splits.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0074", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str74: string = "a1b2c3d4e5";
      const re74: RegExp = new RegExp('\\d', 'g');
      const result74: string[] = str74.split(re74, 3);
      const expected: string[] = ["a", "b", "c"];
      const testPassed: boolean = result74.length === expected.length &&
      result74.every((v, i) => v === expected[i]);
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_7500
     * @tc.name      testStringRegularMethodModuleTestCase0075
     * @tc.desc      Verify String.prototype.match() with an empty non-capturing group regex /(?:)/g produces matches at every position including end.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0075", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str75: string = "test";
      const re75: RegExp = new RegExp('(?:)', 'g');
      const result75: RegExpMatchArray | null = str75.match(re75);
      const expectedLength: number = 5;
      const testPassed: boolean = result75 !== null && result75.length === expectedLength;
      expect(testPassed).assertTrue();
    });


    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_7700
     * @tc.name      testStringRegularMethodModuleTestCase0077
     * @tc.desc      Verify String.prototype.matchAll() with an empty capturing group regex /()/g produces matches at every position including end.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0077", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str77: string = "ab";
      const re77: RegExp = new RegExp('()', 'g');
      const result77: number = Array.from(str77.matchAll(re77)).length;
      const expected: number = 3;
      expect(result77).assertEqual(expected);
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_7800
     * @tc.name      testStringRegularMethodModuleTestCase0078
     * @tc.desc      Verify String.prototype.search() with an empty non-capturing group regex /(?:)/ returns 0 (matches at start).
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0078", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str78: string = "ä»»ä½•å­—ç¬¦ä¸²";
      const re78: RegExp = new RegExp('(?:)');
      const result78: number = str78.search(re78);
      const expected: number = 0;
      expect(result78).assertEqual(expected);
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_7900
     * @tc.name      testStringRegularMethodModuleTestCase0079
     * @tc.desc      Verify String.prototype.replace() with an empty non-capturing group regex /(?:)/g inserts replacement at every position including start and end.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0079", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str79: string = "abc";
      const re79: RegExp = new RegExp('(?:)', 'g');
      const result79: string = str79.replace(re79, "-");
      const expected: string = "-a-b-c-";
      expect(result79).assertEqual(expected);
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_8000
     * @tc.name      testStringRegularMethodModuleTestCase0080
     * @tc.desc      Verify String.prototype.split() with an empty non-capturing group regex /(?:)/ splits at every position including start and end.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0080", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str80: string = "abc";
      const result80: string[] = str80.split('');
      const finalResult = ['', ...result80, ''];
      const expected: string[] = ["", "a", "b", "c", ""];
      const testPassed: boolean = finalResult.length === expected.length &&
      finalResult.every((v, i) => v === expected[i]);
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_8100
     * @tc.name      testStringRegularMethodModuleTestCase0081
     * @tc.desc      Verify String.prototype.match() with /.+/g and /.+/gs:
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0081", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str81: string = "a\nb\nc";
      const re81: RegExp = new RegExp('.+', 'g');
      const re81s: RegExp = new RegExp('.+', 'gs');
      const resultPart1: string = str81.match(re81)?.join("|") ?? "";
      const resultPart2: number = str81.match(re81s)?.[0]?.length ?? 0;
      const testPassed: boolean = resultPart1 === "a|b|c" && resultPart2 === 5;
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_8300
     * @tc.name      testStringRegularMethodModuleTestCase0083
     * @tc.desc      Verify String.prototype.search() with sticky regex /test/y respects lastIndex and returns correct indices.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0083", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str83: string = "testtest";
      const re83: RegExp = new RegExp('test', 'y');
      const result83: number[] = [str83.search(re83)];
      re83.lastIndex = 4;
      result83.push(str83.search(re83));
      expect(result83[0]).assertEqual(0);
      expect(result83[1]).assertEqual(0);
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_8400
     * @tc.name      testStringRegularMethodModuleTestCase0084
     * @tc.desc      Verify String.prototype.replace() with sticky regex /abc/y respects lastIndex and replaces only the match at that position.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0084", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str84: string = "abcabcabc";
      const re84: RegExp = new RegExp('abc', 'y');
      re84.lastIndex = 3;
      const result84: string = str84.replace(re84, "XYZ");
      const testPassed: boolean = result84 === "abcXYZabc";
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_8500
     * @tc.name      testStringRegularMethodModuleTestCase0085
     * @tc.desc      Verify String.prototype.split() with sticky regex /,/y only splits at the first comma because sticky flag restricts matching to lastIndex (default 0).
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0085", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str85: string = "a,b,c,a,b,c";
      const re85 = new RegExp(',', 'y');
      const result85 = str85.split(re85);
      const result = result85.join("|");
      const expected: string = "a|b|c|a|b|c";
      expect(result).assertEqual(expected);
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_8600
     * @tc.name      testStringRegularMethodModuleTestCase0086
     * @tc.desc      Verify String.prototype.match() with a reused global regex object returns consistent results across multiple calls.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0086", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str86: string = "test1 test2 test3";
      const re86: RegExp = new RegExp('test\\d', 'g');
      const match1 = str86.match(re86);
      const match2 = str86.match(re86);
      const resultPart1: string = match1 ? match1.join(",") : "";
      const resultPart2: string = match2 ? match2.join(",") : "";
      const testPassed: boolean = resultPart1 === "test1,test2,test3" && resultPart2 === "test1,test2,test3";
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_8800
     * @tc.name      testStringRegularMethodModuleTestCase0088
     * @tc.desc      Verify String.prototype.search() with a reused regex object returns the same index on multiple calls.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0088", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str88: string = "apple banana cherry";
      const re88: RegExp = new RegExp('banana');
      const result88: number[] = [str88.search(re88), str88.search(re88)];
      const testPassed: boolean = result88[0] === 6 && result88[1] === 6;
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_8900
     * @tc.name      testStringRegularMethodModuleTestCase0089
     * @tc.desc      Verify String.prototype.replace() with a reused global regex object produces consistent results across multiple calls.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0089", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str89: string = "cat dog cat dog";
      const re89: RegExp = new RegExp('cat', 'g');
      const resultPart1: string = str89.replace(re89, "bird");
      const resultPart2: string = str89.replace(re89, "bird");
      const testPassed: boolean = resultPart1 === "bird dog bird dog" && resultPart2 === "bird dog bird dog";
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_9000
     * @tc.name      testStringRegularMethodModuleTestCase0090
     * @tc.desc      Verify String.prototype.split() with a reused regex object produces consistent results across multiple calls.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0090", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str90: string = "a,b,c,d";
      const re90: RegExp = new RegExp(',');
      const resultPart1: string = str90.split(re90).join("|");
      const resultPart2: string = str90.split(re90).join("|");
      const testPassed: boolean = resultPart1 === "a|b|c|d" && resultPart2 === "a|b|c|d";
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_9100
     * @tc.name      testStringRegularMethodModuleTestCase0091
     * @tc.desc      Verify String.prototype.match() with regex /[\u4e00-\u9fa5]+/g correctly matches Chinese characters in a mixed string.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0091", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str91: string = "Hello ä¸–ç•Œ, ä½ å¥½ JavaScript";
      const re91: RegExp = new RegExp('[\\u4e00-\\u9fa5]+', 'g');
      const result91: RegExpMatchArray | null = str91.match(re91);
      const actual: string = result91 ? result91.join(", ") : "";
      const expected: string = "ä¸–ç•Œ, ä½ å¥½";
      const testPassed: boolean = actual === expected;
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_9300
     * @tc.name      testStringRegularMethodModuleTestCase0093
     * @tc.desc      Verify String.prototype.search() with Unicode property escape /\p{Emoji}/u correctly finds the index of an emoji character.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0093", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str93: string = "A string with ğŸ˜€ emoji";
      const re93: RegExp = new RegExp('\\p{Emoji}', 'u');
      const result93: number = str93.search(re93);
      const testPassed: boolean = result93 === 14;
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_9400
     * @tc.name      testStringRegularMethodModuleTestCase0094
     * @tc.desc      Verify String.prototype.replace() correctly replaces Unicode strings containing composed characters like 'Ã©'.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0094", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str94: string = "cafÃ© cafÃ©";
      const re94: RegExp = new RegExp('cafÃ©', 'g');
      const result94: string = str94.replace(re94, "coffee");
      const testPassed: boolean = result94 === "coffee coffee";
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_9500
     * @tc.name      testStringRegularMethodModuleTestCase0095
     * @tc.desc      Verify String.prototype.split() correctly splits a string containing multibyte Chinese characters using a regex with Chinese punctuation.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0095", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str95: string = "ä½ å¥½ï¼Œä¸–ç•Œï¼æ¬¢è¿æ¥åˆ°JavaScriptçš„ä¸–ç•Œã€‚";
      const re95: RegExp = new RegExp('ï¼Œ|ï¼|ã€‚');
      const result95: string[] = str95.split(re95);
      const expected: string[] = ["ä½ å¥½", "ä¸–ç•Œ", "æ¬¢è¿æ¥åˆ°JavaScriptçš„ä¸–ç•Œ", ""];
      const testPassed: boolean = result95.length === expected.length &&
      result95.every((v, i) => v === expected[i]);
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_9600
     * @tc.name      testStringRegularMethodModuleTestCase0096
     * @tc.desc      Verify String.prototype.match() with a basic email regex /\w+@\w+\.\w+/g correctly extracts email addresses from a string.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0096", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str96: string = "Contact us at support@example.com or sales@test.co.uk";
      const re96: RegExp = new RegExp('\\w+@\\w+(\\.\\w+)+', 'g');
      const result96: RegExpMatchArray | null = str96.match(re96);
      const actual: string = result96 ? result96.join(", ") : "";
      const expected: string = "support@example.com, sales@test.co.uk";
      const testPassed: boolean = actual === expected;
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_9800
     * @tc.name      testStringRegularMethodModuleTestCase0098
     * @tc.desc      Verify String.prototype.search() with a basic IP address regex /\d+\.\d+\.\d+\.\d+/ correctly returns the index of the first IP address.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0098", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str98: string = "Server IP: 192.168.1.1, Gateway: 10.0.0.1";
      const re98: RegExp = new RegExp('\\d+\\.\\d+\\.\\d+\\.\\d+');
      const result98: number = str98.search(re98);
      const testPassed: boolean = result98 === 11;
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_CASE_9900
     * @tc.name      testStringRegularMethodModuleTestCase0099
     * @tc.desc      Verify String.prototype.replace() with capturing groups correctly formats a 10-digit phone number into XXX-XXX-XXXX format.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTestCase0099", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str99: string = "Phone: 1234567890";
      const re99: RegExp = new RegExp('(\\d{3})(\\d{3})(\\d{4})');
      const result99: string = str99.replace(re99, "$1-$2-$3");
      const testPassed: boolean = result99 === "Phone: 123-456-7890";
      expect(testPassed).assertTrue();
    });

    /**
     * @tc.number    SUB_BASEDATA_STRING_REGULAR_METHOD_MODULE_TEST_0100
     * @tc.name      testStringRegularMethodModuleTest0001
     * @tc.desc      Verify String.prototype.split() with regex /:/ correctly splits a time string "HH:mm:ss" into parts for formatting.
     * @tc.size      MediumTest
     * @tc.type      Function
     * @tc.level     Level 0
     */
    it("testStringRegularMethodModuleTest0001", TestType.FUNCTION | Size.MEDIUMTEST | Level.LEVEL0, () => {
      const str100: string = "12:34:56";
      const re100: RegExp = new RegExp(':');
      const parts100: string[] = str100.split(re100);
      const result100: string = `${parts100[0]}å°æ—¶${parts100[1]}åˆ†${parts100[2]}ç§’`;
      const testPassed: boolean = result100 === "12å°æ—¶34åˆ†56ç§’";
      expect(testPassed).assertTrue();
    });
  })
}